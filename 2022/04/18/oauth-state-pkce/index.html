<!DOCTYPE html><html lang="zh-tw"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【筆記】OAuth 2.0 的 `state` 與 PKCE · 草飼工程師 | Grass-fed Engineer</title><meta name="description" content="【筆記】OAuth 2.0 的 `state` 與 PKCE - Grass-fed Engineer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="../../../../favicon.png"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="https://grass-fed.engineer/atom.xml" title="草飼工程師 | Grass-fed Engineer"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="草飼工程師 | Grass-fed Engineer" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><p class="site-title">草飼工程師</p></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../https:/www.instagram.com/grass_fed.engineer/" target="_blank">INSTAGRAM</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../atom.xml" target="_self">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【筆記】OAuth 2.0 的 `state` 與 PKCE</h1><div class="post-info">2022年4月18日</div><div class="post-content"><p>前陣子公司需要製作自己的 OAuth Provider，所以看了不少文件，記錄一下跟同事之間切磋、交流後的一些筆記。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h2><p><code>state</code> 在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6749#section-10.12">RFC 6749 #10.12</a> 有提到相關用途，主要是為了防範 CSRF。看了滿多網路上的資源都沒有提到相關的攻擊細節，研究了很久，終於有點心得。</p>
<h3 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h3><p>假設有個網站（<code>grass-fed.engineer</code>），可以讓使用者在上面做筆記，使用者可以在登入後，選擇將筆記存入自己的 GitHub (<code>github.com</code>) 中。</p>
<ol>
<li><p>使用者會先登入 <code>grass-fed.engineer</code>，做完筆記，然後按下按鈕將筆記存入 GitHub 中。</p>
</li>
<li><p>因為會需要存取 GitHub 的資源，按下「存入 GitHub」按鈕後，使用者會被導向 GitHub OAuth 授權存取。這時瀏覽器網址會是</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?redirect_uri=https://grass-fed.engineer/oauth/callback</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用者在 GitHub 完成授權後，會被導向</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://grass-fed.engineer/oauth/callback?code=XMPcVwx8vngm7NhJIAQdQPAwKH2m2YUZ</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client 收到 request，會拿出 <code>code</code>，搭配 <code>client_secret</code> 到 GitHub 交換 <code>access_token</code>。</p>
</li>
</ol>
<h3 id="潛在問題"><a href="#潛在問題" class="headerlink" title="潛在問題"></a>潛在問題</h3><p>一切都看似美好，但是其實任何人都可以透過讓使用者呼叫 <code>https://grass-fed.engineer/oauth/callback?code=&lt;壞人的 code&gt;</code> 來欺騙 client 執行第 4 步。</p>
<p>這樣就有可能使用者綁定的 GitHub 帳號會變成壞人的帳號。</p>
<p>聽起來好像是壞人把自己帳號送了出去，沒什麼好處，但是從此以後，壞人就會拿到所有使用者想存在自己帳號的筆記。</p>
<p>輸出筆記事小，但是如果是 PayPal 存入授權，想來就是會出大事的。</p>
<p>實務上的操作可以是透過網頁的 <code>img</code> tag 嵌入壞人的 URL，讓瀏覽器在下載圖片時變成收到 redirect 請求，進而跳到 <code>grass-fed.engineer</code> 進行帳號授權綁定壞人的 GitHub 帳號。</p>
<h3 id="解方"><a href="#解方" class="headerlink" title="解方"></a>解方</h3><p><code>state</code> 是由 client 產生，令人難以捉摸的一串字，通常會被存放在 cookies 或是 local storage 裡，並且會跟隨第 1 步一起送給 Authorization Server。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?state=9YVefLNc&amp;redirect_uri=https://grass-fed.engineer/oauth/callback</span><br></pre></td></tr></table></figure>

<p>Autorization Server 會在第 3 步重新導向時，在 URI 加入相同的 <code>state</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://grass-fed.engineer/oauth/callback?state=9YVefLNc&amp;code=XMPcVwx8vngm7NhJIAQdQPAwKH2m2YUZ</span><br></pre></td></tr></table></figure>

<p>Client 在收到 request 後，會驗證 URL 中的 <code>state</code> 是否跟 local 的 <code>state</code> 相同，如果是，就代表這個 request 當初是自己發出去的，可以開始兌換 <code>access_token</code>；如果不相同，就代表有可能被偽冒了，必須終止兌換流程。</p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p><code>state</code> 可以用來確保 request 確實是在同一個 client 發送的，而不是他人任意給的假冒 request。</p>
<h2 id="PKCE"><a href="#PKCE" class="headerlink" title="PKCE"></a>PKCE</h2><p>PKCE，全名是 Proof Key for Code Exchange，是 OAuth 2.0 的一種擴充協議。主要是為了解決部分 client 無法安全保護 <code>client_secret</code> 以及 authorization code 時的一種安全驗證機制。</p>
<h3 id="情境-1"><a href="#情境-1" class="headerlink" title="情境"></a>情境</h3><p>最常見的場景是原生手機 app，使用者在瀏覽器上完成 Authorization Server 授權後，Authorization Server 會重新導向至指定 URL。</p>
<p>這種 URL 的 protocol 通常不是 <code>http://</code> 或 <code>https://</code>，而是如 <code>engineer://</code> 這類的 deep link，這樣一來才能夠將使用者導回 app 中。</p>
<p>這類的 deep link 仰賴手機作業系統處理，使用者的手機極有可能暗藏惡意軟體，會從中攔截 <code>code</code>，然後利用 <code>code</code> 換取不當授權。</p>
<h3 id="解方-1"><a href="#解方-1" class="headerlink" title="解方"></a>解方</h3><p>原生手機 app 產生 <code>code_verifier</code>，並利用特定方式生成 <code>code_challenge</code>，詳細內容可以參考 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7636">RFC 7636 #4.1</a>。</p>
<p>在 URL 中加入特定參數 <code>code_challenge</code>，並利用瀏覽器開啟連結進行授權</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/login/oauth/authorize?code_challenge=DU5hBtgoNO7ejhinrnvxNOFvc5JQyA6Ki7MmFsFIdJzViY&amp;redirect_uri=engineer://oauth/callback</span><br></pre></td></tr></table></figure>

<p>Autorization Server 完成授權後，會將 <code>code_challenge</code> 跟 <code>code</code> 存下，之後會導向至</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engineer://oauth/callback?code=9O5avOd4vlOTY6Ye96JSyRxSIDKGQIzF</span><br></pre></td></tr></table></figure>

<p>原生手機 app 開啟，並利用 <code>code</code> 以及 <code>code_verifier</code> 交換 <code>access_token</code>。如果 Authorization Server 上的 <code>code_challenge</code> 跟傳送上來的 <code>code_verifier</code> 相符，則配發 <code>access_token</code>；反之，不配發 <code>access_token</code>。</p>
<p>這樣一來即使 <code>code</code> 被攔截，也很難真的換到 <code>access_token</code>。</p>
<h3 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h3><p>在沒有辦法安全保存 <code>client_secret</code> 的環境中，可以使用 PCKE 產生一次性的驗證金鑰，確保 <code>code</code> 不會任意被攔截並換取不屬於自己的 <code>access_token</code>。</p>
<h2 id="該用什麼？"><a href="#該用什麼？" class="headerlink" title="該用什麼？"></a>該用什麼？</h2><p><code>state</code> 跟 PKCE 看似相似，但效用非常不同：</p>
<ul>
<li><code>state</code>：防止壞人利用自己的 <code>code</code> 讓好人綁錯帳號</li>
<li>PKCE：防止 <code>code</code> 被壞人攔截並挪作他用</li>
</ul>
<p>最佳作法是兩者皆要實作才可以換取較高的安全性。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce">Authorization Code Flow with Proof Key for Code Exchange (PKCE)</a></li>
<li><a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/214980/does-pkce-replace-state-in-the-authorization-code-oauth-flow">Does PKCE replace state in the Authorization Code OAuth flow?</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="next" href="../../../../2021/10/24/tracing-down-lost-sidekiq-jobs/">→</a></div><div class="copyright"><p>© 2021 - 2022 <a href="https://grass-fed.engineer">Grass-fed Engineer</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>